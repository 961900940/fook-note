## mysql知识点汇总

### 索引

### 数据库缓存

### myIsam底层原理及知识点

### InnoDB

InnoDB存储引擎将B+树索引分为聚集索引和非聚集索引。

#### 聚集索引

聚集索引是将主键作为键值来构建B+数，这意味着每张表都有一个主键，如果没有显式创建，则InnoDB存储引擎会自动创建一个6字节的主键。

### MyIsam与InnoDB

### 小知识点

#### 前缀索引

如果需要的索引是很长的字符列，这会让索引变的大且慢。且字符串的前缀差异较大，就可以使用前缀索引。

```
# 语法
ALTER TABLE table_name ADD KEY(column_name(prefix_length));
# 示例
ALTER TABLE city ADD KEY(cityname(7))
```

#### 单列索引

#### 多列索引

#### 复合索引又名联合索引

##### 聚集索引

索引的键值逻辑顺序决定了表数据行的物理存储顺序，也就是在数据库上连接的记录在磁盘上的物理存储地址也是相邻的，注意这一点特性，我们可以分析出它的适用情况。由于聚集索引规定了数据项，也可以说是记录在表中的物理存储顺序，物理顺序唯一，自然每张表中的聚集索引也是唯一的，但是它可以包含多个列，多个字段。

    聚集索引类似于新华字典中用拼音去查找汉字，拼音检索表于书记顺序都是按照a~z排列的，就像相同的逻辑顺序于物理顺序一样，当你需要查找a,ai两个读音的字，或是想一次寻找多个傻(sha)的同音字时，也许向后翻几页，或紧接着下一行就得到结果了。

进一步来说，当你需要查询的数据经常被分组看待（分类），或是经常查询范围性的数据（本月，本周总结），不同值的小数目等情况时，可以使用聚集索引。

##### 非聚集索引

自然，非聚集索引也就是存储的键值逻辑连续，但是在表数据行物理存储顺序上不一定连续的索引，也就是索引的逻辑顺序与磁盘上的物理存储顺序不同。

    非聚集索引类似在新华字典上通过偏旁部首来查询汉字，检索表也许是按照横、竖、撇来排列的，但是由于正文中是a~z的拼音顺序，所以就类似于逻辑地址于物理地址的不对应。同时适用的情况就在于分组，大数目的不同值，频繁更新的列中，这些情况即不适合聚集索引。


#### 覆盖索引

其实mysql可以使用索引来直接获取列的数据。如果索引的叶子节点包含了要查询的数据，那么就不用回表查询了，也就是说这种索引包含（亦称覆盖）所有需要查询的字段的值，我们称这种索引为覆盖索引。

InnoDB
1. 覆盖索引查询时除了除了索引本身的包含的列，还可以使用其默认的聚集索引列。
2. 这跟INNOB的索引结构有关系，主索引是B+树索引存储，也即我们所说的数据行即索引，索引即数据。
3. 对于INNODB的辅助索引，它的叶子节点存储的是索引值和指向主键索引的位置，然后需要通过主键在查询表的字段值，所以辅助索引存储了主键的值。
4. 覆盖索引也可以用上INNODB 默认的聚集索引。
5. innodb引擎的所有储存了主键ID，事务ID，回滚指针,非主键ID，他的查询就会是非主键ID也可覆盖来取得主键ID。

### MySQL索引使用的数据结构：B-Tree和B+Tree

MyISAM是MySQL 5.5之前版本默认的存储引擎，从5.5之后，InnoDB开始成为MySQL默认的存储引擎。

MyISAM使用B-Tree实现主键索引、唯一索引和非主键索引。

InnoDB中非主键索引使用的是B-Tree数据结构，而主键索引使用的是B+Tree。

#### 提高缓存命中率的建议

利用缓存中的数据具有比较严格的条件。其实这些条件也是合情合理的。主要是为了保障数据的一致性。对以上这些条件有深入的认识之后，现在数据库管理员需要考虑的是，如何来提高这个缓存的命中率?对此笔者有如下几个建议。

一是在配置时，客户端与服务器端要使用相同的字符集。如果客户端(或者说第三方工具)与服务器端使用的字符集不同，那么任何情况下都不会使用缓存功能。特别在国内，需要用到中文的字符集。此时特别需要注意，客户端默认字符集要与服务器端的默认字符集相同。注意，这里是相同，而不是兼容。有时候即使采用了不同的字符集，客户端上仍然可以正常显示。这主要是因为有些字符集虽然不相同，但是是相互兼容的。在缓存管理上，需要相同，光兼容还不行。

二是在客户端上，要固化查询的语句。如现在有财务人员和采购人员同时从系统中查询11月份的出货数据。显然他们岗位职责不同，所需要字段的内容是不同的。此时在客户端出，可以允许用户设置自己所需要的表单格式。但是笔者建议，后台所采用的SQL语句最好是相同的。这里数据会经过三个渠道：后台数据库、客户端、用户。笔者的意识时，后台数据库与客户端之间的交互采用相同的SQL语句。然后客户端与用户之间进行交互时，根据用户定义的格式(包括字段前后的排列、不包括查询条件语句的差异)向用户显示数据。此时由于采用了相同的SQL语句(只是用户对于显示格式的要求不同)，从而可以提高应用系统的查询效率。

三是提高内存中缓存的配置，来提高命中率。一般在服务器启动时，操作系统会跟数据库软件协商缓存空间的大小。当缓存工作不足时，缓存中最旧的缓存记录会被最新的消息所覆盖。可见，如果能够提高缓存空间，就可以提高命中率。这就好像打靶，目标多了，命中的几率也会高许多。不过用户的并发数越多，这个设置的效果会越不明显。

四是通过分区表可以提高缓存的命中率。在上面的条件分析中，大家可以看到，只要所查询的表中插入了一条记录，系统就会清空缓存记录。现在以查询出货记录为例。出货记录表每天都在更新，而用户在年初时，会经常需要查询上一年的出货记录。此时由于这个表中的数据每个小时都在更新，那么缓存中的信息会不断的被情况。此时缓存的命中率显然不会很高。针对这种情况，笔者建议可以采用分区表。如可以通过系统设置，将2010年的出货记录单独存放在一个出货的分区表中。即每一个年度都使用一张单独的分区表。此时2011年的纪录，就不会影响到2010年的分区表。此时如果用户重复查询2010年的出货信息，只要其使用的SQL语句相同(没有采用不同的查询条件)，那么就可以享受缓存机制所带来的效益，提高应用系统的查询效果。。